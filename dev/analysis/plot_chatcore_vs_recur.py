"""
Plot ChatCORE metric vs number of recurrences for SFT models.

Reads ChatCORE metrics from markdown report files generated by chat_eval.py
and creates a comparison plot showing how performance changes with test-time
compute (num_recur).

Usage:
    uv run python dev/analysis/plot_chatcore_vs_recur.py
    uv run python dev/analysis/plot_chatcore_vs_recur.py --model-tags r4_sample_2.15e18_s12
"""

import argparse
import re
from pathlib import Path

import matplotlib.pyplot as plt

from nanochat.common import get_base_dir


# Colorblind-safe palette (dark blues/purples + bright accents)
COLORS = [
    "#8cc5e3",  # Bright Mint
    "#0d7d87",  # Bright Cyan
    "#4a2377",  # Deep Navy Blue
    "#f55f74",  # Dusky Purple
    "#FFD166",  # Bright Gold
    "#FF8C42",  # Bright Orange
    "#FF66C4",  # Bright Pink
    "#7EC8E3",  # Bright Sky Blue
]

# Distinct marker styles
MARKERS = ["o", "s", "^", "D", "v", "<", ">", "p", "*", "h", "H", "X"]


def parse_chatcore_from_report(report_path: Path) -> float | None:
    """
    Parse a markdown report file and extract ChatCORE metric.

    Args:
        report_path: Path to markdown report file

    Returns:
        ChatCORE value as float, or None if not found
    """
    try:
        with open(report_path, encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line.startswith("- ChatCORE metric:"):
                    # Extract float value after the colon
                    value_str = line.split(":", 1)[1].strip().split()[0]
                    return float(value_str)
    except (OSError, ValueError):
        return None
    return None


def parse_report_filename(filename: str) -> tuple[str, int] | None:
    """
    Parse filename to extract model_tag and num_recur.

    Expected format: chat-evaluation-sft-{model_tag}-(r={num_recur}).md

    Args:
        filename: Report filename

    Returns:
        (model_tag, num_recur) tuple, or None if parsing fails
    """
    # Pattern: chat-evaluation-sft-{model_tag}-(r={num_recur}).md
    pattern = r"^chat-evaluation-sft-(.+)-\(r=(\d+)\)\.md$"
    match = re.match(pattern, filename)
    if match:
        model_tag = match.group(1)
        num_recur = int(match.group(2))
        return (model_tag, num_recur)
    return None


def collect_data(report_dir: Path, model_tags_filter: list[str] | None = None) -> dict:
    """
    Collect all ChatCORE results from markdown report files.

    Args:
        report_dir: Directory containing report files
        model_tags_filter: Optional list of model tags to include

    Returns:
        dict: {model_tag: {num_recur: chatcore_value}}
    """
    data = {}

    for report_file in report_dir.glob("chat-evaluation-sft-*.md"):
        parsed = parse_report_filename(report_file.name)
        if parsed is None:
            continue

        model_tag, num_recur = parsed

        # Apply filter
        if model_tags_filter is not None and model_tag not in model_tags_filter:
            continue

        # Parse ChatCORE value
        chatcore = parse_chatcore_from_report(report_file)
        if chatcore is None:
            continue

        # Store in nested dict
        if model_tag not in data:
            data[model_tag] = {}
        data[model_tag][num_recur] = chatcore

    return data


def create_short_label(model_tag: str) -> str:
    """Create a shorter, more readable label from model_tag."""
    # Remove FLOPs count and seed suffix
    # Example: "r4_sample_2.15e18_s12" -> "r4_sample"
    label = re.sub(r"_[\d.]+e\d+_s\d+$", "", model_tag)
    return label


def plot_chatcore_vs_recur(data: dict, output_path: Path):
    """Create plot of ChatCORE vs num_recur for each model."""
    fig, ax = plt.subplots(figsize=(10, 6))

    # Plot each model
    for idx, model_tag in enumerate(sorted(data.keys())):
        recur_dict = data[model_tag]

        # Extract and sort by num_recur
        recur_vals = sorted(recur_dict.keys())
        chatcore_vals = [recur_dict[r] for r in recur_vals]

        # Create label
        label = create_short_label(model_tag)

        # Plot with colorblind-safe colors and distinct markers
        color = COLORS[idx % len(COLORS)]
        marker = MARKERS[idx % len(MARKERS)]

        ax.plot(
            recur_vals,
            chatcore_vals,
            marker=marker,
            markersize=8,
            linewidth=2,
            linestyle="-",
            color=color,
            label=label,
        )

    # Add visual marks for specific recurrence ranges
    # Shaded region for num_recur=2-16
    ax.axvspan(2, 16, alpha=0.15, color="gray", zorder=0, label="sample range")

    # Vertical line mark at num_recur=4
    ax.axvline(x=4, color="darkred", linestyle="--", linewidth=2, alpha=0.7, zorder=1, label="mean train recur")

    # Styling
    ax.set_xlabel("Number of Recurrences", fontsize=12, fontweight="bold")
    ax.set_ylabel("ChatCORE Metric\n(0=random baseline, 1=perfect)", fontsize=12, fontweight="bold")
    ax.set_title("Test-Time Compute Scaling: ChatCORE vs Recurrence Depth", fontsize=14, fontweight="bold")
    ax.grid(True, alpha=0.3, linestyle="--")
    ax.legend(loc="best", framealpha=0.9)

    # Set x-axis to show integer recurrence values
    if data:
        all_recur_vals = set()
        for model_tag in data:
            all_recur_vals.update(data[model_tag].keys())
        ax.set_xticks(sorted(all_recur_vals))


    plt.tight_layout()

    # Save plot
    output_path.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    print(f"Plot saved to: {output_path}")

    # Also save as PDF for papers
    pdf_path = output_path.with_suffix(".pdf")
    plt.savefig(pdf_path, bbox_inches="tight")
    print(f"PDF saved to: {pdf_path}")


def main():
    parser = argparse.ArgumentParser(description="Plot ChatCORE vs number of recurrences")
    parser.add_argument("--model-tags", nargs="+", default=None, help="Filter by specific model tags")
    parser.add_argument("--output", type=str, default=None, help="Output path (default: plots/chatcore_vs_recur.png)")
    args = parser.parse_args()

    # Get base directory
    base_dir = Path(get_base_dir())
    report_dir = base_dir / "report"

    if not report_dir.exists():
        print(f"Error: report directory not found at {report_dir}")
        return

    # Collect data
    print("Collecting ChatCORE results from report files...")
    data = collect_data(report_dir, model_tags_filter=args.model_tags)

    if not data:
        print("No ChatCORE report files found matching the filters.")
        print(f"Looking in: {report_dir}")
        if args.model_tags:
            print(f"Model tags filter: {args.model_tags}")
        return

    # Print summary
    print(f"\nFound results for {len(data)} model(s):")
    for model_tag, recur_dict in sorted(data.items()):
        recur_vals = sorted(recur_dict.keys())
        chatcore_vals = [recur_dict[r] for r in recur_vals]
        print(f"  {model_tag}: {len(recur_vals)} recurrence values {recur_vals}")
        for r, c in zip(recur_vals, chatcore_vals):
            print(f"    r={r}: ChatCORE={c:.4f}")

    # Create plot
    output_path = Path(args.output) if args.output else (base_dir / "plots" / "chatcore_vs_recur.png")
    print(f"\nCreating plot...")
    plot_chatcore_vs_recur(data, output_path)


if __name__ == "__main__":
    main()
